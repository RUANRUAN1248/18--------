C251 COMPILER V5.60.0,  SEEKFREE_IMU660RA                                                  25/06/23  16:28:08  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE SEEKFREE_IMU660RA
OBJECT MODULE PLACED IN .\Out_File\SEEKFREE_IMU660RA.obj
COMPILER INVOKED BY: D:\keil\keil251\C251\BIN\C251.EXE ..\..\Libraries\seekfree_peripheral\SEEKFREE_IMU660RA.c XSMALL WA
                    -RNINGLEVEL(3) BROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_periph
                    -eral;..\CODE;..\USER\inc;..\USER\src;..\..\..\DIANCI) DEBUG PRINT(.\Out_File\SEEKFREE_IMU660RA.lst) OBJECT(.\Out_File\SE
                    -EKFREE_IMU660RA.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * MM32F327X-G9P Opensourec Library å³ï¼ˆMM32F327X-G9P å¼€æºåº“ï¼‰æ˜¯ä¸€ä¸ªåŸºäºå®˜æ–¹ SDK æ¥å£çš„ç¬¬
             -ä¸‰æ–¹å¼€æºåº“
    3          * Copyright (c) 2022 SEEKFREE é€é£ç§‘æŠ€
    4          * 
    5          * æœ¬æ–‡ä»¶æ˜¯ MM32F327X-G9P å¼€æºåº“çš„ä¸€éƒ¨åˆ†
    6          * 
    7          * MM32F327X-G9P å¼€æºåº“ æ˜¯å…è´¹è½¯ä»¶
    8          * æ‚¨å¯ä»¥æ ¹æ®è‡ªç”±è½¯ä»¶åŸºé‡‘ä¼šå‘å¸ƒçš„ GPLï¼ˆGNU General Public Licenseï¼Œå³ GNUé€šç”¨å…¬å…±è®¸
             -å¯è¯ï¼‰çš„æ¡æ¬¾
    9          * å³ GPL çš„ç¬¬3ç‰ˆï¼ˆå³ GPL3.0ï¼‰æˆ–ï¼ˆæ‚¨é€‰æ‹©çš„ï¼‰ä»»ä½•åæ¥çš„ç‰ˆæœ¬ï¼Œé‡æ–°å‘å¸ƒå’Œ/æˆ–ä¿®æ”
             -¹å®ƒ
   10          * 
   11          * æœ¬å¼€æºåº“çš„å‘å¸ƒæ˜¯å¸Œæœ›å®ƒèƒ½å‘æŒ¥ä½œç”¨ï¼Œä½†å¹¶æœªå¯¹å…¶ä½œä»»ä½•çš„ä¿è¯
   12          * ç”šè‡³æ²¡æœ‰éšå«çš„é€‚é”€æ€§æˆ–é€‚åˆç‰¹å®šç”¨é€”çš„ä¿è¯
   13          * æ›´å¤šç»†èŠ‚è¯·å‚è§ GPL
   14          * 
   15          * æ‚¨åº”è¯¥åœ¨æ”¶åˆ°æœ¬å¼€æºåº“çš„åŒæ—¶æ”¶åˆ°ä¸€ä»½ GPL çš„å‰¯æœ¬
   16          * å¦‚æœæ²¡æœ‰ï¼Œè¯·å‚é˜…<https://www.gnu.org/licenses/>
   17          * 
   18          * é¢å¤–æ³¨æ˜ï¼š
   19          * æœ¬å¼€æºåº“ä½¿ç”¨ GPL3.0 å¼€æºè®¸å¯è¯åè®® ä»¥ä¸Šè®¸å¯ç”³æ˜ä¸ºè¯‘æ–‡ç‰ˆæœ¬
   20          * è®¸å¯ç”³æ˜è‹±æ–‡ç‰ˆåœ¨ libraries/doc æ–‡ä»¶å¤¹ä¸‹çš„ GPL3_permission_statement.txt æ–‡ä»¶ä¸­
   21          * è®¸å¯è¯å‰¯æœ¬åœ¨ libraries æ–‡ä»¶å¤¹ä¸‹ å³è¯¥æ–‡ä»¶å¤¹ä¸‹çš„ LICENSE æ–‡ä»¶
   22          * æ¬¢è¿å„ä½ä½¿ç”¨å¹¶ä¼ æ’­æœ¬ç¨‹åº ä½†ä¿®æ”¹å†…å®¹æ—¶å¿…é¡»ä¿ç•™é€é£ç§‘æŠ€çš„ç‰ˆæƒå£°æ˜ï¼ˆå³æœ¬
             -å£°æ˜ï¼‰
   23          * 
   24          * æ–‡ä»¶åç§°          zf_device_imu660ra
   25          * å…¬å¸åç§°          æˆéƒ½é€é£ç§‘æŠ€æœ‰é™å…¬å¸
   26          * ç‰ˆæœ¬ä¿¡æ¯          æŸ¥çœ‹ libraries/doc æ–‡ä»¶å¤¹å†… version æ–‡ä»¶ ç‰ˆæœ¬è¯´æ˜
   27          * å¼€å‘ç¯å¢ƒ          IAR 8.32.4 or MDK 5.37
   28          * é€‚ç”¨å¹³å°          MM32F327X_G9P
   29          * åº—é“ºé“¾æ¥          https://seekfree.taobao.com/
   30          * 
   31          * ä¿®æ”¹è®°å½•
   32          * æ—¥æœŸ              ä½œè€…                å¤‡æ³¨
   33          * 2022-09-15        pudding             first version
   34          *********************************************************************************************************
             -***********/
   35          /********************************************************************************************************
             -*************
   36          * æ¥çº¿å®šä¹‰ï¼š
   37          *                   ------------------------------------
   38          *                   æ¨¡å—ç®¡è„š            å•ç‰‡æœºç®¡è„š
   39          *                   // ç¡¬ä»¶ SPI å¼•è„š
   40          *                   SCL/SPC           æŸ¥çœ‹ zf_device_imu660ra.h ä¸­ IMU660RA_SPC_PIN å®å®šä¹‰
   41          *                   SDA/DSI           æŸ¥çœ‹ zf_device_imu660ra.h ä¸­ IMU660RA_SDI_PIN å®å®šä¹‰
   42          *                   SA0/SDO           æŸ¥çœ‹ zf_device_imu660ra.h ä¸­ IMU660RA_SDO_PIN å®å®šä¹‰
   43          *                   CS                æŸ¥çœ‹ zf_device_imu660ra.h ä¸­ IMU660RA_CS_PIN å®å®šä¹‰
   44          *                   VCC               3.3Vç”µæº
   45          *                   GND               ç”µæºåœ°
   46          *                   å…¶ä½™å¼•è„šæ‚¬ç©º
   47          *
   48          *                   // è½¯ä»¶ IIC å¼•è„š
   49          *                   SCL/SPC           æŸ¥çœ‹ zf_device_imu660ra.h ä¸­ IMU660RA_SCL_PIN å®å®šä¹‰
C251 COMPILER V5.60.0,  SEEKFREE_IMU660RA                                                  25/06/23  16:28:08  PAGE 2   

   50          *                   SDA/DSI           æŸ¥çœ‹ zf_device_imu660ra.h ä¸­ IMU660RA_SDA_PIN å®å®šä¹‰
   51          *                   VCC               3.3Vç”µæº
   52          *                   GND               ç”µæºåœ°
   53          *                   å…¶ä½™å¼•è„šæ‚¬ç©º
   54          *                   ------------------------------------
   55          *********************************************************************************************************
             -***********/
   56          
   57          #include "SEEKFREE_IMU660RA.h"
   58          
   59          #include "SEEKFREE_CONFIG.h"
   60          
   61          #include "zf_delay.h"
   62          #include "zf_spi.h"
   63          
   64          
   65          #pragma warning disable = 177
   66          #pragma warning disable = 183
   67          
   68          
   69          int16 imu660ra_gyro_x = 0, imu660ra_gyro_y = 0, imu660ra_gyro_z = 0;            // ä¸‰è½´é™€èºä»ªæ•°æ® 
             -  gyro (é™€èºä»ª)
   70          int16 imu660ra_acc_x = 0, imu660ra_acc_y = 0, imu660ra_acc_z = 0;               // ä¸‰è½´åŠ é€Ÿåº¦è®¡æ•°æ
             -® acc  (accelerometer åŠ é€Ÿåº¦è®¡)
   71          
   72          #if IMU660RA_USE_SOFT_IIC
               
               #define GET_IMU660RA_SDA                                IMU660RA_SDA_PIN
               #define IMU660RA_SCL_LOW()              IMU660RA_SCL_PIN = 0            //IOå£è¾“å‡ºä½ç”µå¹³
               #define IMU660RA_SCL_HIGH()             IMU660RA_SCL_PIN = 1            //IOå£è¾“å‡ºé«˜ç”µå¹³
               #define IMU660RA_SDA_LOW()              IMU660RA_SDA_PIN = 0            //IOå£è¾“å‡ºä½ç”µå¹³
               #define IMU660RA_SDA_HIGH()             IMU660RA_SDA_PIN = 1            //IOå£è¾“å‡ºé«˜ç”µå¹³
               
               
               #define ack 1      //ä¸»åº”ç­”
               #define no_ack 0   //ä»åº”ç­”  
               
               //-------------------------------------------------------------------------------------------------------
             -------------
               //  @brief      æ¨¡æ‹ŸIICå»¶æ—¶
               //  @return     void                                            
               //  @since      v1.0
               //  Sample usage:                               å¦‚æœIICé€šè®¯å¤±è´¥å¯ä»¥å°è¯•å¢åŠ jçš„å€¼
               //-------------------------------------------------------------------------------------------------------
             -------------
               static void imu660ra_simiic_delay(void)
               {
                   uint16 j=IMU660RA_SOFT_IIC_DELAY;   
                       while(j--);
               }
               
               //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
               static void imu660ra_simiic_start(void)
               {
                       IMU660RA_SDA_HIGH();
                       IMU660RA_SCL_HIGH();
                       imu660ra_simiic_delay();
                       IMU660RA_SDA_LOW();
                       imu660ra_simiic_delay();
                       IMU660RA_SCL_LOW();
               }
               
               //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
               static void imu660ra_simiic_stop(void)
               {
                       IMU660RA_SDA_LOW();
C251 COMPILER V5.60.0,  SEEKFREE_IMU660RA                                                  25/06/23  16:28:08  PAGE 3   

                       IMU660RA_SCL_LOW();
                       imu660ra_simiic_delay();
                       IMU660RA_SCL_HIGH();
                       imu660ra_simiic_delay();
                       IMU660RA_SDA_HIGH();
                       imu660ra_simiic_delay();
               }
               
               //ä¸»åº”ç­”(åŒ…å«ack:SDA=0å’Œno_ack:SDA=0)
               //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
               static void imu660ra_simiic_sendack(unsigned char ack_dat)
               {
                   IMU660RA_SCL_LOW();
                       imu660ra_simiic_delay();
                       if(ack_dat) IMU660RA_SDA_LOW();
                   else        IMU660RA_SDA_HIGH();
               
                   IMU660RA_SCL_HIGH();
                   imu660ra_simiic_delay();
                   IMU660RA_SCL_LOW();
                   imu660ra_simiic_delay();
               }
               
               
               static int imu660ra_sccb_waitack(void)
               {
                   IMU660RA_SCL_LOW();
               
                       imu660ra_simiic_delay();
                       
                       IMU660RA_SCL_HIGH();
                   imu660ra_simiic_delay();
                       
                   if(GET_IMU660RA_SDA)           //åº”ç­”ä¸ºé«˜ç”µå¹³ï¼Œå¼‚å¸¸ï¼Œé€šä¿¡å¤±è´¥
                   {
               
                       IMU660RA_SCL_LOW();
                       return 0;
                   }
               
                   IMU660RA_SCL_LOW();
                       imu660ra_simiic_delay();
                   return 1;
               }
               
               //å­—èŠ‚å‘é€ç¨‹åº
               //å‘é€c(å¯ä»¥æ˜¯æ•°æ®ä¹Ÿå¯æ˜¯åœ°å€)ï¼Œé€å®Œåæ¥æ”¶ä»åº”ç­”
               //ä¸è€ƒè™‘ä»åº”ç­”ä½
               //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
               static void imu660ra_send_ch(uint8 c)
               {
                       uint8 i = 8;
                   while(i--)
                   {
                       if(c & 0x80)    IMU660RA_SDA_HIGH();//SDA è¾“å‡ºæ•°æ®
                       else                    IMU660RA_SDA_LOW();
                       c <<= 1;
                       imu660ra_simiic_delay();
                       IMU660RA_SCL_HIGH();                //SCL æ‹‰é«˜ï¼Œé‡‡é›†ä¿¡å·
                       imu660ra_simiic_delay();
                       IMU660RA_SCL_LOW();                //SCL æ—¶é’Ÿçº¿æ‹‰ä½
                   }
                       imu660ra_sccb_waitack();
               }
               
               
C251 COMPILER V5.60.0,  SEEKFREE_IMU660RA                                                  25/06/23  16:28:08  PAGE 4   

               //å­—èŠ‚æ¥æ”¶ç¨‹åº
               //æ¥æ”¶å™¨ä»¶ä¼ æ¥çš„æ•°æ®ï¼Œæ­¤ç¨‹åºåº”é…åˆ|ä¸»åº”ç­”å‡½æ•°|ä½¿ç”¨
               //å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
               static uint8 imu660ra_read_ch(uint8 ack_x)
               {
                   uint8 i;
                   uint8 c;
                   c=0;
                   IMU660RA_SCL_LOW();
                   imu660ra_simiic_delay();
                   IMU660RA_SDA_HIGH();             
               
                   for(i=0;i<8;i++)
                   {
                       imu660ra_simiic_delay();
                       IMU660RA_SCL_LOW();         //ç½®æ—¶é’Ÿçº¿ä¸ºä½ï¼Œå‡†å¤‡æ¥æ”¶æ•°æ®ä½
                       imu660ra_simiic_delay();
                       IMU660RA_SCL_HIGH();         //ç½®æ—¶é’Ÿçº¿ä¸ºé«˜ï¼Œä½¿æ•°æ®çº¿ä¸Šæ•°æ®æœ‰æ•ˆ
                       imu660ra_simiic_delay();
                       c<<=1;
                       if(GET_IMU660RA_SDA) 
                       {
                           c+=1;   //è¯»æ•°æ®ä½ï¼Œå°†æ¥æ”¶çš„æ•°æ®å­˜c
                       }
                   }
               
                       IMU660RA_SCL_LOW();
                       imu660ra_simiic_delay();
                       imu660ra_simiic_sendack(ack_x);
                       
                   return c;
               }
               
               
               //-------------------------------------------------------------------------------------------------------
             -------------
               //  @brief      æ¨¡æ‹ŸIICå†™æ•°æ®åˆ°è®¾å¤‡å¯„å­˜å™¨å‡½æ•°
               //  @param      dev_add                 è®¾å¤‡åœ°å€(ä½ä¸ƒä½åœ°å€)
               //  @param      reg                             å¯„å­˜å™¨åœ°å€
               //  @param      dat                             å†™å…¥çš„æ•°æ®
               //  @return     void                                            
               //  @since      v1.0
               //  Sample usage:                               
               //-------------------------------------------------------------------------------------------------------
             -------------
               static void imu660ra_simiic_write_reg(uint8 dev_add, uint8 reg, uint8 dat)
               {
                       imu660ra_simiic_start();
                   imu660ra_send_ch( (dev_add<<1) | 0x00);   //å‘é€å™¨ä»¶åœ°å€åŠ å†™ä½
                       imu660ra_send_ch( reg );                                 //å‘é€ä»æœºå¯„å­˜å™¨åœ°å€
                       imu660ra_send_ch( dat );                                 //å‘é€éœ€è¦å†™å…¥çš„æ•°æ®
                       imu660ra_simiic_stop();
               }
               
               //-------------------------------------------------------------------------------------------------------
             -------------
               //  @brief      æ¨¡æ‹ŸIICå†™æ•°æ®åˆ°è®¾å¤‡å¯„å­˜å™¨å‡½æ•°
               //  @param      dev_add                 è®¾å¤‡åœ°å€(ä½ä¸ƒä½åœ°å€)
               //  @param      reg                             å¯„å­˜å™¨åœ°å€
               //  @param      dat                             å†™å…¥çš„æ•°æ®
               //  @return     void                                            
               //  @since      v1.0
               //  Sample usage:                               
               //-------------------------------------------------------------------------------------------------------
             -------------
               static void imu660ra_simiic_write_regs(uint8 dev_add, uint8 reg, uint8 *dat, uint32 len)
C251 COMPILER V5.60.0,  SEEKFREE_IMU660RA                                                  25/06/23  16:28:08  PAGE 5   

               {
                       uint16 i = 0;
                       imu660ra_simiic_start();
                   imu660ra_send_ch( (dev_add<<1) | 0x00);   //å‘é€å™¨ä»¶åœ°å€åŠ å†™ä½
                       imu660ra_send_ch( reg );                                 //å‘é€ä»æœºå¯„å­˜å™¨åœ°å€
               
                       while(len--)
                       {
                               imu660ra_send_ch( *dat++ );                              //å‘é€éœ€è¦å†™å…¥çš„æ•°æ®
                       }
               
                       
                       imu660ra_simiic_stop();
               }
               //-------------------------------------------------------------------------------------------------------
             -------------
               //  @brief      æ¨¡æ‹ŸIICä»è®¾å¤‡å¯„å­˜å™¨è¯»å–æ•°æ®
               //  @param      dev_add                 è®¾å¤‡åœ°å€(ä½ä¸ƒä½åœ°å€)
               //  @param      reg                             å¯„å­˜å™¨åœ°å€
               //  @param      type                    é€‰æ‹©é€šä¿¡æ–¹å¼æ˜¯IIC  è¿˜æ˜¯ SCCB
               //  @return     uint8                   è¿”å›å¯„å­˜å™¨çš„æ•°æ®                        
               //  @since      v1.0
               //  Sample usage:                               
               //-------------------------------------------------------------------------------------------------------
             -------------
               static uint8 imu660ra_simiic_read_reg(uint8 dev_add, uint8 reg)
               {
                       uint8 dat;
                       imu660ra_simiic_start();
                   imu660ra_send_ch( (dev_add<<1) | 0x00);  //å‘é€å™¨ä»¶åœ°å€åŠ å†™ä½
                       imu660ra_send_ch( reg );                                //å‘é€ä»æœºå¯„å­˜å™¨åœ°å€
                       
                       imu660ra_simiic_start();
                       imu660ra_send_ch( (dev_add<<1) | 0x01);  //å‘é€å™¨ä»¶åœ°å€åŠ è¯»ä½
                       dat = imu660ra_read_ch(no_ack);                                 //è¯»å–æ•°æ®
                       imu660ra_simiic_stop();
                       
                       return dat;
               }
               
               //-------------------------------------------------------------------------------------------------------
             -------------
               //  @brief      æ¨¡æ‹ŸIICè¯»å–å¤šå­—èŠ‚æ•°æ®
               //  @param      dev_add                 è®¾å¤‡åœ°å€(ä½ä¸ƒä½åœ°å€)
               //  @param      reg                             å¯„å­˜å™¨åœ°å€
               //  @param      dat_add                 æ•°æ®ä¿å­˜çš„åœ°å€æŒ‡é’ˆ
               //  @param      num                             è¯»å–å­—èŠ‚æ•°é‡
               //  @param      type                    é€‰æ‹©é€šä¿¡æ–¹å¼æ˜¯IIC  è¿˜æ˜¯ SCCB
               //  @return     uint8                   è¿”å›å¯„å­˜å™¨çš„æ•°æ®                        
               //  @since      v1.0
               //  Sample usage:                               
               //-------------------------------------------------------------------------------------------------------
             -------------
               static void imu660ra_simiic_read_regs(uint8 dev_add, uint8 reg, uint8 *dat_add, uint32 num)
               {
                       imu660ra_simiic_start();
                   imu660ra_send_ch( (dev_add<<1) | 0x00);  //å‘é€å™¨ä»¶åœ°å€åŠ å†™ä½
                       imu660ra_send_ch( reg );                                //å‘é€ä»æœºå¯„å­˜å™¨åœ°å€
                       
                       imu660ra_simiic_start();
                       imu660ra_send_ch( (dev_add<<1) | 0x01);  //å‘é€å™¨ä»¶åœ°å€åŠ è¯»ä½
                   while(--num)
                   {
                       *dat_add = imu660ra_read_ch(ack); //è¯»å–æ•°æ®
                       dat_add++;
                   }
C251 COMPILER V5.60.0,  SEEKFREE_IMU660RA                                                  25/06/23  16:28:08  PAGE 6   

                   *dat_add = imu660ra_read_ch(no_ack); //è¯»å–æ•°æ®
                       imu660ra_simiic_stop();
               }
               
               #define imu660ra_write_register(reg, dat)        (imu660ra_simiic_write_reg(IMU660RA_DEV_ADDR, (reg), (da
             -t)))
               #define imu660ra_write_registers(reg, dat, len)  (imu660ra_simiic_write_regs(IMU660RA_DEV_ADDR, (reg), (d
             -at), (len)))
               #define imu660ra_read_register(reg)              (imu660ra_simiic_read_reg(IMU660RA_DEV_ADDR, (reg)))
               #define imu660ra_read_registers(reg, dat, len)   (imu660ra_simiic_read_regs(IMU660RA_DEV_ADDR, (reg), (da
             -t), (len)))
               
               #else
  311          
  312          
  313          #define IMU660RA_SCK(x)                         IMU660RA_SPC_PIN  = x
  314          #define IMU660RA_MOSI(x)                        IMU660RA_SDI_PIN = x
  315          #define IMU660RA_CS(x)                          IMU660RA_CS_PIN  = x
  316          #define IMU660RA_MISO                           IMU660RA_SDO_PIN 
  317          
  318          
  319          //-------------------------------------------------------------------------------------------------------
             -------------
  320          //  @brief      é€šè¿‡SPIå†™ä¸€ä¸ªbyte,åŒæ—¶è¯»å–ä¸€ä¸ªbyte
  321          //  @param      byte        å‘é€çš„æ•°æ®    
  322          //  @return     uint8       return è¿”å›statusçŠ¶æ€
  323          //  @since      v1.0
  324          //  Sample usage:
  325          //-------------------------------------------------------------------------------------------------------
             -------------
  326          static uint8 imu660ra_simspi_wr_byte(uint8 byte)
  327          {
  328   1          uint8 i;
  329   1              
  330   1          for(i=0; i<8; i++)
  331   1          {
  332   2              IMU660RA_MOSI(byte&0x80);
  333   2              byte <<= 1;
  334   2                      IMU660RA_SCK (0);
  335   2                      IMU660RA_SCK (0);
  336   2                      IMU660RA_SCK (1);
  337   2                      IMU660RA_SCK (1);
  338   2                      
  339   2                      byte |= IMU660RA_MISO; 
  340   2          }   
  341   1          return(byte);                                               
  342   1      }
  343          //-------------------------------------------------------------------------------------------------------
             -------------
  344          //  @brief      å°†valå†™å…¥cmdå¯¹åº”çš„å¯„å­˜å™¨åœ°å€,åŒæ—¶è¿”å›statuså­—èŠ‚
  345          //  @param      cmd         å‘½ä»¤å­—
  346          //  @param      val         å¾…å†™å…¥å¯„å­˜å™¨çš„æ•°å€¼
  347          //  @since      v1.0
  348          //  Sample usage:
  349          //-------------------------------------------------------------------------------------------------------
             -------------
  350          static void imu660ra_simspi_w_reg_byte(uint8 cmd, uint8 val)
  351          {
  352   1          cmd |= IMU660RA_SPI_W;
  353   1          imu660ra_simspi_wr_byte(cmd);                       
  354   1          imu660ra_simspi_wr_byte(val);                                                                               
  355   1      }
  356          
  357          
  358          //-------------------------------------------------------------------------------------------------------
             -------------
C251 COMPILER V5.60.0,  SEEKFREE_IMU660RA                                                  25/06/23  16:28:08  PAGE 7   

  359          //  @brief      å°†valå†™å…¥cmdå¯¹åº”çš„å¯„å­˜å™¨åœ°å€
  360          //  @param      cmd         å‘½ä»¤å­—
  361          //  @param      val         å¾…å†™å…¥å¯„å­˜å™¨çš„æ•°å€¼
  362          //  @since      v1.0
  363          //  Sample usage:
  364          //-------------------------------------------------------------------------------------------------------
             -------------
  365          static void imu660ra_simspi_w_reg_bytes(uint8 cmd, uint8 *dat_addr, uint32 len)
  366          {
  367   1          cmd |= IMU660RA_SPI_W;
  368   1          imu660ra_simspi_wr_byte(cmd);   
  369   1              while(len--)
  370   1              {
  371   2                      imu660ra_simspi_wr_byte(*dat_addr++);   
  372   2              }                                                                       
  373   1      }
  374          
  375          //-------------------------------------------------------------------------------------------------------
             -------------
  376          //  @brief      è¯»å–cmdæ‰€å¯¹åº”çš„å¯„å­˜å™¨åœ°å€
  377          //  @param      cmd         å‘½ä»¤å­—
  378          //  @param      *val        å­˜å‚¨è¯»å–çš„æ•°æ®åœ°å€
  379          //  @since      v1.0
  380          //  Sample usage:
  381          //-------------------------------------------------------------------------------------------------------
             -------------
  382          //static void imu660ra_simspi_r_reg_byte(uint8 cmd, uint8 *val)
  383          //{
  384          //    IMU660RA_CS(0);
  385          //    cmd |= IMU660RA_SPI_R;
  386          //    imu660ra_simspi_wr_byte(cmd);                                     
  387          //    *val = imu660ra_simspi_wr_byte(0);                                
  388          //    IMU660RA_CS(1);                                           
  389          //}
  390          
  391          //-------------------------------------------------------------------------------------------------------
             -------------
  392          //  @brief      è¯»å–cmdæ‰€å¯¹åº”çš„å¯„å­˜å™¨åœ°å€
  393          //  @param      cmd         å‘½ä»¤å­—
  394          //  @param      *val        å­˜å‚¨è¯»å–çš„æ•°æ®åœ°å€
  395          //  @param      num         è¯»å–çš„æ•°é‡
  396          //  @since      v1.0
  397          //  Sample usage:
  398          //-------------------------------------------------------------------------------------------------------
             -------------
  399          static void imu660ra_simspi_r_reg_bytes(uint8 cmd, uint8 *val, uint32 num)
  400          {
  401   1          cmd |= IMU660RA_SPI_R;
  402   1          imu660ra_simspi_wr_byte(cmd);
  403   1              
  404   1              while(num--)
  405   1              {
  406   2                      *val++ = imu660ra_simspi_wr_byte(0);
  407   2              }
  408   1      }
  409          
  410          
  411          //-------------------------------------------------------------------------------------------------------
             -------------
  412          // å‡½æ•°ç®€ä»‹     IMU660RA å†™å¯„å­˜å™¨
  413          // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
  414          // å‚æ•°è¯´æ˜     dat            æ•°æ®
  415          // è¿”å›å‚æ•°     void
  416          // ä½¿ç”¨ç¤ºä¾‹     imu660ra_write_register(IMU660RA_PWR_CONF, 0x00);                   // å…³é—­é«˜çº§çœ
             -ç”µæ¨¡å¼
  417          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
C251 COMPILER V5.60.0,  SEEKFREE_IMU660RA                                                  25/06/23  16:28:08  PAGE 8   

  418          //-------------------------------------------------------------------------------------------------------
             -------------
  419          static void imu660ra_write_register(uint8 reg, uint8 dat)
  420          {
  421   1          IMU660RA_CS(0);
  422   1          imu660ra_simspi_w_reg_byte(reg | IMU660RA_SPI_W, dat);
  423   1          IMU660RA_CS(1);
  424   1      }
  425          
  426          //-------------------------------------------------------------------------------------------------------
             -------------
  427          // å‡½æ•°ç®€ä»‹     IMU660RA å†™æ•°æ®
  428          // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
  429          // å‚æ•°è¯´æ˜     dat            æ•°æ®
  430          // è¿”å›å‚æ•°     void
  431          // ä½¿ç”¨ç¤ºä¾‹     imu660ra_write_registers(IMU660RA_INIT_dat, imu660ra_config_file, sizeof(imu660ra_con
             -fig_file));
  432          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  433          //-------------------------------------------------------------------------------------------------------
             -------------
  434          static void imu660ra_write_registers(uint8 reg, const uint8 *dat, uint32 len)
  435          {
  436   1          IMU660RA_CS(0);
  437   1      
  438   1          imu660ra_simspi_w_reg_bytes(reg | IMU660RA_SPI_W, dat, len);
  439   1          IMU660RA_CS(1);
  440   1      }
  441          
  442          //-------------------------------------------------------------------------------------------------------
             -------------
  443          // å‡½æ•°ç®€ä»‹     IMU660RA è¯»å¯„å­˜å™¨
  444          // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
  445          // è¿”å›å‚æ•°     uint8           æ•°æ®
  446          // ä½¿ç”¨ç¤ºä¾‹     imu660ra_read_register(IMU660RA_CHIP_ID);
  447          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  448          //-------------------------------------------------------------------------------------------------------
             -------------
  449          static uint8 imu660ra_read_register(uint8 reg)
  450          {
  451   1          uint8 dat[2];
  452   1          IMU660RA_CS(0);
  453   1          imu660ra_simspi_r_reg_bytes(reg | IMU660RA_SPI_R, dat, 2);
  454   1          IMU660RA_CS(1);
  455   1          return dat[1];
  456   1      }
  457          
  458          //-------------------------------------------------------------------------------------------------------
             -------------
  459          // å‡½æ•°ç®€ä»‹     IMU660RA è¯»æ•°æ®
  460          // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
  461          // å‚æ•°è¯´æ˜     dat            æ•°æ®ç¼“å†²åŒº
  462          // å‚æ•°è¯´æ˜     len             æ•°æ®é•¿åº¦
  463          // è¿”å›å‚æ•°     void
  464          // ä½¿ç”¨ç¤ºä¾‹     imu660ra_read_registers(IMU660RA_ACC_ADDRESS, dat, 6);
  465          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  466          //-------------------------------------------------------------------------------------------------------
             -------------
  467          static void imu660ra_read_registers(uint8 reg, uint8 *dat, uint32 len)
  468          {
  469   1          IMU660RA_CS(0);
  470   1          imu660ra_simspi_r_reg_bytes(reg | IMU660RA_SPI_R, dat, len);
  471   1              IMU660RA_CS(1);
  472   1      }
  473          #endif
  474          
  475          //-------------------------------------------------------------------------------------------------------
C251 COMPILER V5.60.0,  SEEKFREE_IMU660RA                                                  25/06/23  16:28:08  PAGE 9   

             -------------
  476          // å‡½æ•°ç®€ä»‹     IMU660RA è‡ªæ£€
  477          // å‚æ•°è¯´æ˜     void
  478          // è¿”å›å‚æ•°     uint8           1-è‡ªæ£€å¤±è´¥ 0-è‡ªæ£€æˆåŠŸ
  479          // ä½¿ç”¨ç¤ºä¾‹     imu660ra_self_check();
  480          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  481          //-------------------------------------------------------------------------------------------------------
             -------------
  482          static uint8 imu660ra_self_check (void)
  483          {
  484   1          uint8 dat = 0, return_state = 0;
  485   1          uint16 timeout_count = 0;
  486   1          do
  487   1          {
  488   2              if(timeout_count ++ > IMU660RA_TIMEOUT_COUNT)
  489   2              {
  490   3                  return_state =  1;
  491   3                  break;
  492   3              }
  493   2              dat = imu660ra_read_register(IMU660RA_CHIP_ID);
  494   2              delay_ms(1);
  495   2          }while(0x24 != dat);                                                        // è¯»å–è®¾å¤‡IDæ˜¯å¦ç­
             -‰äº0X24ï¼Œå¦‚æœä¸æ˜¯0X24åˆ™è®¤ä¸ºæ²¡æ£€æµ‹åˆ°è®¾å¤‡
  496   1          return return_state;
  497   1      }
  498          
  499          //-------------------------------------------------------------------------------------------------------
             -------------
  500          // å‡½æ•°ç®€ä»‹     è·å– IMU660RA åŠ é€Ÿåº¦è®¡æ•°æ®
  501          // å‚æ•°è¯´æ˜     void
  502          // è¿”å›å‚æ•°     void
  503          // ä½¿ç”¨ç¤ºä¾‹     imu660ra_get_acc();                                             // æ‰§è¡Œè¯¥å‡½æ•°å
             -ï¼Œç›´æ¥æŸ¥çœ‹å¯¹åº”çš„å˜é‡å³å¯
  504          // å¤‡æ³¨ä¿¡æ¯     ä½¿ç”¨ SPI çš„é‡‡é›†æ—¶é—´ä¸º69us
  505          //             ä½¿ç”¨ IIC çš„é‡‡é›†æ—¶é—´ä¸º126us        é‡‡é›†åŠ é€Ÿåº¦è®¡çš„æ—¶é—´ä¸é‡‡é›†é™€èºä»ªçš„
             -æ—¶é—´ä¸€è‡´çš„åŸå› æ˜¯éƒ½åªæ˜¯è¯»å–å¯„å­˜å™¨æ•°æ®
  506          //-------------------------------------------------------------------------------------------------------
             -------------
  507          void imu660ra_get_acc (void)
  508          {
  509   1      #if IMU660RA_USE_SOFT_IIC
                       uint8 dat[6];
                   imu660ra_read_registers(IMU660RA_ACC_ADDRESS, dat, 6);
                   imu660ra_acc_x = (int16)(((uint16)dat[1]<<8 | dat[0]));
                   imu660ra_acc_y = (int16)(((uint16)dat[3]<<8 | dat[2]));
                   imu660ra_acc_z = (int16)(((uint16)dat[5]<<8 | dat[4]));
               #else
  516   1              // SPIè¯»å–ç¬¬ä¸€ä¸ªåœ°å€ä¸ºç©º
  517   1              uint8 dat[7];
  518   1              imu660ra_read_registers(IMU660RA_ACC_ADDRESS, dat, 7);
  519   1          imu660ra_acc_x = (int16)(((uint16)dat[2]<<8 | dat[1]));
  520   1          imu660ra_acc_y = (int16)(((uint16)dat[4]<<8 | dat[3]));
  521   1          imu660ra_acc_z = (int16)(((uint16)dat[6]<<8 | dat[5]));
  522   1      #endif
  523   1      }
  524          //-------------------------------------------------------------------------------------------------------
             -------------
  525          // å‡½æ•°ç®€ä»‹     è·å– IMU660RA é™€èºä»ªæ•°æ®
  526          // å‚æ•°è¯´æ˜     void
  527          // è¿”å›å‚æ•°     void
  528          // ä½¿ç”¨ç¤ºä¾‹     imu660ra_get_gyro();                                            // æ‰§è¡Œè¯¥å‡½æ•°å
             -ï¼Œç›´æ¥æŸ¥çœ‹å¯¹åº”çš„å˜é‡å³å¯
  529          // å¤‡æ³¨ä¿¡æ¯     ä½¿ç”¨ SPI çš„é‡‡é›†æ—¶é—´ä¸º69us
  530          //             ä½¿ç”¨ IIC çš„é‡‡é›†æ—¶é—´ä¸º126us
  531          //-------------------------------------------------------------------------------------------------------
             -------------
C251 COMPILER V5.60.0,  SEEKFREE_IMU660RA                                                  25/06/23  16:28:08  PAGE 10  

  532          void imu660ra_get_gyro (void)
  533          {
  534   1      #if IMU660RA_USE_SOFT_IIC
                   uint8 dat[6];
                   imu660ra_read_registers(IMU660RA_GYRO_ADDRESS, dat, 6);
                   imu660ra_gyro_x = (int16)(((uint16)dat[1]<<8 | dat[0]));
                   imu660ra_gyro_y = (int16)(((uint16)dat[3]<<8 | dat[2]));
                   imu660ra_gyro_z = (int16)(((uint16)dat[5]<<8 | dat[4]));
               #else
  541   1              // SPIè¯»å–ç¬¬ä¸€ä¸ªåœ°å€ä¸ºç©º
  542   1              uint8 dat[7];
  543   1              imu660ra_read_registers(IMU660RA_GYRO_ADDRESS, dat, 7);
  544   1          imu660ra_gyro_x = (int16)(((uint16)dat[2]<<8 | dat[1]));
  545   1          imu660ra_gyro_y = (int16)(((uint16)dat[4]<<8 | dat[3]));
  546   1          imu660ra_gyro_z = (int16)(((uint16)dat[6]<<8 | dat[5]));
  547   1      #endif
  548   1      }
  549          
  550          //-------------------------------------------------------------------------------------------------------
             -------------
  551          // å‡½æ•°ç®€ä»‹     å°† IMU660RA åŠ é€Ÿåº¦è®¡æ•°æ®è½¬æ¢ä¸ºå®é™…ç‰©ç†æ•°æ®
  552          // å‚æ•°è¯´æ˜     gyro_value      ä»»æ„è½´çš„åŠ é€Ÿåº¦è®¡æ•°æ®
  553          // è¿”å›å‚æ•°     void
  554          // ä½¿ç”¨ç¤ºä¾‹     float dat = imu660ra_acc_transition(imu660ra_acc_x);           // å•ä½ä¸º g(m/s^2)
  555          // å¤‡æ³¨ä¿¡æ¯
  556          //-------------------------------------------------------------------------------------------------------
             -------------
  557          float imu660ra_acc_transition (int16 acc_value)
  558          {
  559   1          float acc_dat = 0;
  560   1          switch((uint8)IMU660RA_ACC_SAMPLE)
  561   1          {
  562   2              case 0x00: acc_dat = (float)acc_value / 16384; break;                  // 0x00 åŠ é€Ÿåº¦è®¡é‡ç¨‹
             -ä¸º:Â±2g     è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ® é™¤ä»¥ 16384     å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ï¼šg(m/s^2)
  563   2              case 0x01: acc_dat = (float)acc_value / 8192; break;                   // 0x01 åŠ é€Ÿåº¦è®¡é‡ç¨‹
             -ä¸º:Â±4g     è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ® é™¤ä»¥ 8192      å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ï¼šg(m/s^2)
  564   2              case 0x02: acc_dat = (float)acc_value / 4096; break;                   // 0x02 åŠ é€Ÿåº¦è®¡é‡ç¨‹
             -ä¸º:Â±8g     è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ® é™¤ä»¥ 4096      å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ï¼šg(m/s^2)
  565   2              case 0x03: acc_dat = (float)acc_value / 2048; break;                   // 0x03 åŠ é€Ÿåº¦è®¡é‡ç¨‹
             -ä¸º:Â±16g    è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ® é™¤ä»¥ 2048      å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ï¼šg(m/s^2)
  566   2              default: break;
  567   2          }
  568   1          return acc_dat;
  569   1      }
  570          
  571          //-------------------------------------------------------------------------------------------------------
             -------------
  572          // å‡½æ•°ç®€ä»‹     å°† IMU660RA é™€èºä»ªæ•°æ®è½¬æ¢ä¸ºå®é™…ç‰©ç†æ•°æ®
  573          // å‚æ•°è¯´æ˜     gyro_value      ä»»æ„è½´çš„é™€èºä»ªæ•°æ®
  574          // è¿”å›å‚æ•°     void
  575          // ä½¿ç”¨ç¤ºä¾‹     float dat = imu660ra_gyro_transition(imu660ra_gyro_x);         // å•ä½ä¸ºÂ°/s
  576          // å¤‡æ³¨ä¿¡æ¯
  577          //-------------------------------------------------------------------------------------------------------
             -------------
  578          float imu660ra_gyro_transition (int16 gyro_value)
  579          {
  580   1          float gyro_dat = 0;
  581   1          switch(IMU660RA_GYR_SAMPLE)
  582   1          {
  583   2              case 0x00: gyro_dat = (float)gyro_value / 16.4f;  break;               //  0x00 é™€èºä»ªé‡ç¨‹ä¸
             -º:Â±2000dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 16.4    å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸ºï¼šÂ°/s
  584   2              case 0x01: gyro_dat = (float)gyro_value / 32.8f;  break;               //  0x01 é™€èºä»ªé‡ç¨‹ä¸
             -º:Â±1000dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 32.8    å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸ºï¼šÂ°/s
  585   2              case 0x02: gyro_dat = (float)gyro_value / 65.6f;  break;               //  0x02 é™€èºä»ªé‡ç¨‹ä¸
             -º:Â±500 dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 65.6    å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸ºï¼šÂ°/s
  586   2              case 0x03: gyro_dat = (float)gyro_value / 131.2f; break;               //  0x03 é™€èºä»ªé‡ç¨‹ä¸
C251 COMPILER V5.60.0,  SEEKFREE_IMU660RA                                                  25/06/23  16:28:08  PAGE 11  

             -º:Â±250 dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 131.2   å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸ºï¼šÂ°/s
  587   2              case 0x04: gyro_dat = (float)gyro_value / 262.4f; break;               //  0x04 é™€èºä»ªé‡ç¨‹ä¸
             -º:Â±125 dps    è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 262.4   å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸ºï¼šÂ°/s
  588   2              default: break;
  589   2          }
  590   1          return gyro_dat;
  591   1      }
  592          
  593          //-------------------------------------------------------------------------------------------------------
             -------------
  594          // å‡½æ•°ç®€ä»‹     åˆå§‹åŒ– IMU660RA
  595          // å‚æ•°è¯´æ˜     void
  596          // è¿”å›å‚æ•°     uint8           1-åˆå§‹åŒ–å¤±è´¥ 0-åˆå§‹åŒ–æˆåŠŸ
  597          // ä½¿ç”¨ç¤ºä¾‹     imu660ra_init();
  598          // å¤‡æ³¨ä¿¡æ¯
  599          //-------------------------------------------------------------------------------------------------------
             -------------
  600          uint8 imu660ra_init (void)
  601          {
  602   1          uint8 return_state = 0;
  603   1          delay_ms(20);                                                                       // ç­‰å¾…è®¾å¤‡ä¸Šç”µæˆåŠŸ
  604   1      
  605   1      //#if IMU660RA_USE_SOFT_IIC 
  606   1      
  607   1      //#else
  608   1      //      imu660ra_read_register(IMU660RA_CHIP_ID);                                   // è¯»å–ä¸€ä¸‹è®¾å¤‡ID å°
             -†è®¾å¤‡è®¾ç½®ä¸ºSPIæ¨¡å¼
  609   1      //      imu660ra_read_register(IMU660RA_CHIP_ID);                                   // è¯»å–ä¸€ä¸‹è®¾å¤‡ID å°
             -†è®¾å¤‡è®¾ç½®ä¸ºSPIæ¨¡å¼
  610   1      //      imu660ra_read_register(IMU660RA_CHIP_ID);                                   // è¯»å–ä¸€ä¸‹è®¾å¤‡ID å°
             -†è®¾å¤‡è®¾ç½®ä¸ºSPIæ¨¡å¼
  611   1      
  612   1      //#endif
  613   1              
  614   1          do{
  615   2              if(imu660ra_self_check())                                               // IMU660RA è‡ªæ£€
  616   2              {
  617   3                  // å¦‚æœç¨‹åºåœ¨è¾“å‡ºäº†æ–­è¨€ä¿¡æ¯ å¹¶ä¸”æç¤ºå‡ºé”™ä½ç½®åœ¨è¿™é‡Œ
  618   3                  // é‚£ä¹ˆå°±æ˜¯ IMU660RA è‡ªæ£€å‡ºé”™å¹¶è¶…æ—¶é€€å‡ºäº†
  619   3                  // æ£€æŸ¥ä¸€ä¸‹æ¥çº¿æœ‰æ²¡æœ‰é—®é¢˜ å¦‚æœæ²¡é—®é¢˜å¯èƒ½å°±æ˜¯åäº†
  620   3                              while(1)
  621   3                              {
  622   4                                      printf("imu660ra self check error.\r\n");
  623   4                                      delay_ms(200);
  624   4                              };
  625   3                  return_state = 1;
  626   3                  //break;
  627   3              }
  628   2      
  629   2              imu660ra_write_register(IMU660RA_PWR_CONF, 0x00);                       // å…³é—­é«˜çº§çœç”µæ¨¡å
             -¼
  630   2              delay_ms(10);
  631   2              imu660ra_write_register(IMU660RA_INIT_CTRL, 0x00);                      // å¼€å§‹å¯¹æ¨¡å—è¿›è¡Œå
             -ˆå§‹åŒ–é…ç½®
  632   2              imu660ra_write_registers(IMU660RA_INIT_DATA, imu660ra_config_file, sizeof(imu660ra_config_file));
             -   // è¾“å‡ºé…ç½®æ–‡ä»¶
  633   2              imu660ra_write_register(IMU660RA_INIT_CTRL, 0x01);                      // åˆå§‹åŒ–é…ç½®ç»“æŸ
  634   2              delay_ms(20);
  635   2              if(imu660ra_read_register(IMU660RA_INT_STA) == 0)                       // æ£€æŸ¥æ˜¯å¦é…ç½®å®Œæ
             -ˆ
  636   2              {
  637   3                  // å¦‚æœç¨‹åºåœ¨è¾“å‡ºäº†æ–­è¨€ä¿¡æ¯ å¹¶ä¸”æç¤ºå‡ºé”™ä½ç½®åœ¨è¿™é‡Œ
  638   3                  // é‚£ä¹ˆå°±æ˜¯ IMU660RA é…ç½®åˆå§‹åŒ–æ–‡ä»¶å‡ºé”™äº†
  639   3                  // æ£€æŸ¥ä¸€ä¸‹æ¥çº¿æœ‰æ²¡æœ‰é—®é¢˜ å¦‚æœæ²¡é—®é¢˜å¯èƒ½å°±æ˜¯åäº†
  640   3      //                      while(1)
  641   3      //                      {
C251 COMPILER V5.60.0,  SEEKFREE_IMU660RA                                                  25/06/23  16:28:08  PAGE 12  

  642   3                                      printf("imu660ra init error.\r\n");
  643   3      //                              delay_ms(200);
  644   3      //                      }
  645   3                  return_state = 1;
  646   3                  //break;
  647   3              }
  648   2              imu660ra_write_register(IMU660RA_PWR_CTRL, 0x0E);                       // å¼€å¯æ€§èƒ½æ¨¡å¼  ä½
             -¿èƒ½é™€èºä»ªã€åŠ é€Ÿåº¦ã€æ¸©åº¦ä¼ æ„Ÿå™¨
  649   2              imu660ra_write_register(IMU660RA_ACC_CONF, 0xA7);                       // åŠ é€Ÿåº¦é‡‡é›†é…ç½® 
             -æ€§èƒ½æ¨¡å¼ æ­£å¸¸é‡‡é›† 50Hz  é‡‡æ ·é¢‘ç‡
  650   2              imu660ra_write_register(IMU660RA_GYR_CONF, 0xA9);                       // é™€èºä»ªé‡‡é›†é…ç½® 
             -æ€§èƒ½æ¨¡å¼ æ­£å¸¸é‡‡é›† 200Hz é‡‡æ ·é¢‘ç‡
  651   2                      
  652   2              imu660ra_write_register(IMU660RA_ACC_RANGE, IMU660RA_ACC_SAMPLE);       // åŠ é€Ÿåº¦é‡ç¨‹é…ç½® 
             -é…ç½®é‡ç¨‹ä¸º:Â±8g
  653   2                      // IMU660RA_ACC_SAMPLE å¯„å­˜å™¨
  654   2              // è®¾ç½®ä¸º:0x00 é™€èºä»ªé‡ç¨‹ä¸º:Â±2000dps     è·å–åˆ°çš„é™€èºä»ªæ•°æ® é™¤ä»¥ 16.4       
             -å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸ºï¼šÂ°/s
  655   2              // è®¾ç½®ä¸º:0x01 é™€èºä»ªé‡ç¨‹ä¸º:Â±1000dps     è·å–åˆ°çš„é™€èºä»ªæ•°æ® é™¤ä»¥ 32.8       
             -å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸ºï¼šÂ°/s
  656   2              // è®¾ç½®ä¸º:0x02 é™€èºä»ªé‡ç¨‹ä¸º:Â±500 dps     è·å–åˆ°çš„é™€èºä»ªæ•°æ® é™¤ä»¥ 65.6       
             -å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸ºï¼šÂ°/s
  657   2              // è®¾ç½®ä¸º:0x03 é™€èºä»ªé‡ç¨‹ä¸º:Â±250 dps     è·å–åˆ°çš„é™€èºä»ªæ•°æ® é™¤ä»¥ 131.2      
             -å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸ºï¼šÂ°/s
  658   2              // è®¾ç½®ä¸º:0x04 é™€èºä»ªé‡ç¨‹ä¸º:Â±125 dps     è·å–åˆ°çš„é™€èºä»ªæ•°æ® é™¤ä»¥ 262.4      
             -å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ä¸ºï¼šÂ°/s
  659   2                      
  660   2              imu660ra_write_register(IMU660RA_GYR_RANGE, IMU660RA_GYR_SAMPLE);       // é™€èºä»ªé‡ç¨‹é…ç½® 
             -é…ç½®é‡ç¨‹ä¸º:Â±2000dps
  661   2              // IMU660RA_GYR_RANGE å¯„å­˜å™¨
  662   2              // è®¾ç½®ä¸º:0x00 åŠ é€Ÿåº¦è®¡é‡ç¨‹ä¸º:Â±2g         è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ® é™¤ä»¥ 16384 
             -  å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ï¼šg(m/s^2)
  663   2              // è®¾ç½®ä¸º:0x01 åŠ é€Ÿåº¦è®¡é‡ç¨‹ä¸º:Â±4g         è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ® é™¤ä»¥ 8192  
             -  å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ï¼šg(m/s^2)
  664   2              // è®¾ç½®ä¸º:0x02 åŠ é€Ÿåº¦è®¡é‡ç¨‹ä¸º:Â±8g         è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ® é™¤ä»¥ 4096  
             -  å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ï¼šg(m/s^2)
  665   2              // è®¾ç½®ä¸º:0x03 åŠ é€Ÿåº¦è®¡é‡ç¨‹ä¸º:Â±16g        è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ® é™¤ä»¥ 2048  
             -  å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ® å•ä½ï¼šg(m/s^2)
  666   2          
  667   2              }while(0);
  668   1          return return_state;
  669   1      }
  670          
  671          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       555     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        12         24
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        88     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
